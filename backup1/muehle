package muehle

//import io.javalin.Javalin
//import io.javalin.core.PathSegment
//import io.javalin.http.Context
//import kotlin.math.max
//import kotlin.math.min
import java.io.File

const val UP = 0
const val RIGHT = 1
const val DOWN = 2
const val LEFT = 3
const val WHITE = 1
const val BLACK = -1

val myMap = HashMap<Long, Int>()
var countMoves = 0  //calculated Moves in order for AI to make a single choice
var start = System.currentTimeMillis()
val maxDepth = 5
val timeLimit = -1

val paths = arrayOf(mapOf(2 to 7, 1 to 1), mapOf(3 to 0, 2 to 9, 1 to 2), mapOf(3 to 1, 2 to 3),
        mapOf(0 to 2, 2 to 4, 3 to 11), mapOf(0 to 3, 3 to 5), mapOf(0 to 13, 1 to 4, 3 to 6),
        mapOf(0 to 7, 1 to 5), mapOf(0 to 0, 1 to 15, 2 to 6), mapOf(1 to 9, 2 to 15),
        mapOf(0 to 1, 1 to 10, 2 to 17, 3 to 8), mapOf(2 to 11, 3 to 9), mapOf(0 to 10, 1 to 3, 2 to 12, 3 to 19),
        mapOf(0 to 11, 3 to 13), mapOf(0 to 21, 1 to 12, 2 to 5, 3 to 14), mapOf(0 to 15, 1 to 13),
        mapOf(0 to 8, 1 to 23, 2 to 14, 3 to 7), mapOf(1 to 17, 2 to 23), mapOf(0 to 9, 1 to 18, 3 to 16),
        mapOf(2 to 19, 3 to 17), mapOf(0 to 18, 1 to 11, 2 to 20), mapOf(0 to 19, 3 to 21),
        mapOf(1 to 20, 2 to 13, 3 to 22), mapOf(0 to 23, 1 to 21), mapOf(0 to 16, 2 to 22, 3 to 15))
//24 maps, one for each node, constituting a graph, 0 = UP, 1 = RIGHT, 2 = DOWN, 3 = LEFT

class Muehle(val nodes: IntArray, val sel: Int, val turn: Int, val avl: Int, val phs: Int, val last: Muehle? = null) {
    //n[0...23] represents the nodes
    //sel is current sel
    //avl is number of remaining rounds of inserting(short for avl)
    //phs is the phase: 1 is insert, 0 is regular, -1 take out
    //last holds the previous game position
    companion object {
        const val f1: Int = 0b000101010001010100010101
        const val f2: Int = 0b010000000100000001000000
        const val f3: Int = 0b000000000000000010101010

        init {
            File("src/main/resources/database.txt").forEachLine {
                val line = it.split(",")
                myMap.put(line[0].toLong(), line[1].toInt())
            }
        }
    }

    val n = IntArray(24)
//    val allPos = ArrayList<Muehle>()
//    val possibleNodes = ArrayList<IntArray>()
//    val m = Muehle(intArrayOf(2), -1, 1, 18, 1, null)

    init {
//        buildField(IntArray(24), 0, 0, 0)
//        buildPos()
//        allPositions.forEach {
//            it.evaluate(myMap,it.turn,0)
//        }
        repeat(24) {
            n[it] = node(it)
        }
    }

    fun turn90(): Muehle {
        val nodesTmp = IntArray(24)
        for (i in 0..23) {
            if ((i % 8) > 1) nodesTmp[i] = n[i - 2]
            else nodesTmp[i] = n[i + 6]
        }
        return Muehle(arrayToBits(nodesTmp), sel, turn, avl, phs, this)
    }

    fun mirror(): Muehle {
        val nodesTmp = IntArray(24)
        for (i in 0..23) {
            if ((i % 8) == 0 || (i % 8) == 4) nodesTmp[i] = n[i + 2]
            else if ((i % 8) == 2 || (i % 8) == 6) nodesTmp[i] = n[i - 2]
            else if ((i % 8) == 3) nodesTmp[i] = n[i + 4]
            else if ((i % 8) == 7) nodesTmp[i] = n[i - 4]
            else nodesTmp[i] = n[i]
        }
        return Muehle(arrayToBits(nodesTmp), sel, turn, avl, phs, this)
    }

    fun invert(): Muehle {
        val nodesTmp = IntArray(24)
        for (i in 0..23) {
            if (i <= 7) nodesTmp[i] = n[i + 16]
            else if (i >= 16) nodesTmp[i] = n[i - 16]
            else nodesTmp[i] = n[i]
        }
        return Muehle(arrayToBits(nodesTmp), sel, turn, avl, phs, this)
    }

    fun getHash(): Long {
        var res = 0L

        //arrange board, so equivalent constellations will have same hash
        // --to be implemented--

        //number of tokens to insert
        res += avl
        res = res.shl(4)

        //current phase
        if (phs == -1) res += 2
        else res += phs
        res = res.shl(2)

        //tokens of both players, opponent first
        for (t in intArrayOf(-turn, turn)) {
            for (i in 0..23) {
                res = res.shl(1)
                if (n[i] == t) res++
            }
        }
        return res
    }

    fun setHash(value: Int) {
        //puts same entry for 16 different hashcodes due to transformation
        //4 different angles, mirrored and not mirrored, inverted and not inverted
        myMap[getHash()] = value
//        var m = this
//        repeat(2) {
//            repeat(2) {
//                repeat(4) {
//                    myMap[m.getHash()] = value
//                    m = m.turn90()
//                }
//                m = m.mirror()
//            }
//            m = m.invert()
//        }
    }

    fun evaluate(hm: HashMap<Long, Int>, turn: Int, depth: Int): Int {
//        println("reached evaluate")
        countMoves++
        //generate hashcode
        var hash: Long
        val depth = if (phs == -1) depth - 1 else depth
        var m = this
        repeat(2) {
            repeat(2) {
                repeat(4) {
                    hm[m.getHash()]?.let { value ->
                        return value * turn
                    }
                    m = m.turn90()
                }
                m = m.mirror()
            }
            m = m.invert()
        }

        //limit evaluation to prevent overflow
        if (gameOver() || depth==maxDepth ||
                (timeLimit!=-1 && System.currentTimeMillis()-start > timeLimit))
            return turn * heuristicEval()

        val next = play(getBestMove(depth + 1))
        val hashValue = next.evaluate(myMap, next.turn, depth + 1) * turn
        println("reached setHash")
        setHash(hashValue)
        return turn * hashValue
    }

    fun heuristicEval(): Int {
        //gameOver:             -100000
        //each token ahead:      +10000
        //each row of 2:          +3000/-2000
        //each row of 1:          +1000/-1000
        //? each double mill:      +30000 ?
        if (gameOver()) return -100000;

        var res = (countByColor(turn) - countByColor(-turn)) * 10000

        var numOfRows = countAllRows(turn)
        res += numOfRows[0] * 100
        res += numOfRows[1] * 3000
        numOfRows = countAllRows(-turn)
        res -= numOfRows[0] * 100
        res -= numOfRows[1] * 2000

        if (turn == -1 && avl > 0) res += 10000
        if (phs == -1 && avl == 0) res += 10000
        return res
    }

    fun getBestMove(depth: Int): Move {
        val pM = possibleMoves()
        var bestMove: Move = pM.random()
        var bestVal = -100000
        pM.forEach {
            val next = play(it)
//            println(next.turn)
            var thisVal = noise(next.evaluate(myMap, next.turn, depth))
            if (turn == -1) thisVal *= -1
            if (depth == 0) println("$it / $thisVal");
            if (thisVal > bestVal) {
                bestMove = it
                bestVal = thisVal
            }
        }
        if (depth == 0) println(bestVal)
        return bestMove
    }

    fun makeMove(m: Move): Muehle {
        return play(m)
    }

    fun undo(): Muehle {
        if (last == null) return this
        return last
    }

    fun play(m: Move): Muehle {
        if (gameOver()) return this
        val nodesTmp = nodes.copyOf()
        val player = if (turn == 1) 0 else 1
        val opponent = if (player == 0) 1 else 0
        if (m.to == -1) {
            nodesTmp[opponent] -= 1.shl(m.from)
            return Muehle(nodesTmp, -1, -turn, avl, if (avl > 1) 1 else 0, this)
        }
        if (m.from == -1) nodesTmp[player] += 1.shl(m.to)
        else {
            nodesTmp[player] += 1.shl(m.to)
            nodesTmp[player] -= 1.shl(m.from)
        }
        var res = Muehle(nodesTmp, -1, -turn, avl - if (avl != 0) 1 else 0, if (avl > 1) 1 else 0, this)
        if (res.rowOfThree(m.to)) res = Muehle(res.nodes, res.sel, -res.turn, res.avl, -1, this)
        return res
    }

    fun randomMove(): Move {
        return possibleMoves().random()
    }

    fun bestMove(): Move {
        countMoves = 0
        start = System.currentTimeMillis()
        val bestMove = getBestMove(0)
        println("Calculated $countMoves Moves in " +
                (System.currentTimeMillis() - start) + " ms")
        return bestMove
    }

    fun possibleMoves(): List<Move> {
        val pMoves = arrayListOf<Move>()
        if (phs == 1) {
            for (i in 0..23) {
                if (n[i] == 0) pMoves.add(Move(-1, i))
            }
        }
        if (phs == -1) {
            for (i in 0..23) {
                if (n[i] == -turn && !rowOfThree(i)) pMoves.add(Move(i, -1))
            }
            if (pMoves.isEmpty())
                for (i in 0..23) {
                    if (n[i] == -turn) pMoves.add(Move(i, -1))
                }
        }
        if (phs == 0) {
            if (countByColor(turn) > 3)
                for (i in 0..23) {
                    if (n[i] == turn) paths[i].values.forEach {
                        if (n[it] == 0) pMoves.add(Move(i, it))
                    }
                }
            else
                for (i in 0..23) {
                    if (n[i] == turn) for (j in 0..23) {
                        if (n[j] == 0) pMoves.add(Move(i, j))
                    }
                }
        }
        return pMoves
    }

    fun click(node: Int): Muehle {

        //used when page is refreshed
        if (node == -1) return this

        //Insert
        if (phs == 1 && n[node] == 0) {
            return this.play(Move(-1, node))
        }

        //Take out
        if (phs == -1 && n[node] == -turn && (!rowOfThree(node) || allMills())) {
            return this.play(Move(node, -1))
        }

        //Move selected token
        if (sel != -1 && n[node] == 0 && (paths[sel].containsValue(node) || countByColor(turn) <= 3)) {
            return play(Move(sel, node))
        }

        //Select own Token
        if (phs == 0 && n[node] == turn)
            return Muehle(nodes, node, turn, avl, phs, this)

        //Deselect
        return Muehle(nodes, -1, turn, avl, phs, this)

    }

    fun rowOfThree(node: Int): Boolean {
        //return true if node is part of a row of three
        if (n[node] == 0) return false
        val turn = n[node]
        for (i in 0..1) {    //0 = vertikal, 1 = horizontal
            if (adj(node, i) == turn) {
                if (adj(paths[node][i]!!, i) == turn) return true
                if (adj(node, i + 2) == turn) return true
            }
            if (adj(node, i + 2) == turn) {
                if (adj(paths[node][i + 2]!!, i + 2) == turn) return true
            }
        }
        return false
    }

    fun rowOfThreeBit(color: Int): Boolean {
//        val own = if (color==1) white else black
//        if (own.and(own.shr(1)).and(own.shr(2)).and(f1)>0) return true
//        if (own.and(own.shr(1)).and(own.shl(6)).and(f2)>0) return true
//        if (own.and(own.shr(8)).and(own.shr(16)).and(f3)>0) return true
        return false
    }

    fun countAllRows(color: Int): IntArray {
        val allRows = IntArray(3)
        val countAllRows = IntArray(3)
        val occOpp = occupiedRows(-color)

        //rowsOfThree
        allRows[2] = rowsOfThree(color)

        //rowsOfTwo
        allRows[1] = rowsOfTwo(color, rowsOfZero(color), occOpp)

        //rowsOfOne
        allRows[0] = rowsOfOne(color, rowsOfThree(color), occOpp)

        //count
        repeat(3) {
            countAllRows[it] = countBits(allRows[it])
        }

        return countAllRows
    }

    fun rowsOfZero(color: Int): Int {
        val own = if (color == 1) nodes[0] else nodes[1]
        return own.or(own.shr(1)).or(own.shr(2)).inv().and(f1) +
                own.or(own.shr(1)).or(own.shl(6)).inv().and(f2) +
                own.or(own.shr(8)).or(own.shr(16)).inv().and(f3)
    }

    fun rowsOfThree(color: Int): Int {
        val own = if (color == 1) nodes[0] else nodes[1]
        return own.and(own.shr(1)).and(own.shr(2)).and(f1) +
                own.and(own.shr(1)).and(own.shl(6)).and(f2) +
                own.and(own.shr(8)).and(own.shr(16)).and(f3)
    }

    fun rowsOfTwo(color: Int, rowsOfZero: Int, occupiedByOpponent: Int): Int {
        val own = if (color == 1) nodes[0] else nodes[1]
        val inv = own.inv()
        return rowsOfZero.inv().and(
                (inv.xor(inv.shr(1)).xor(inv.shr(2))).and(f1).and(occupiedByOpponent.inv()) +
                        (inv.xor(inv.shr(1)).xor(inv.shl(6))).and(f2).and(occupiedByOpponent.inv()) +
                        (inv.xor(inv.shr(8)).xor(inv.shr(16))).and(f3).and(occupiedByOpponent.inv()))
    }

    fun rowsOfOne(color: Int, rowsOfThree: Int, occupiedByOpponent: Int): Int {
        val own = if (color == 1) nodes[0] else nodes[1]
        return rowsOfThree.inv().and(
                own.xor(own.shr(1)).xor(own.shr(2)).and(f1).and(occupiedByOpponent.inv()) +
                        own.xor(own.shr(1)).xor(own.shl(6)).and(f2).and(occupiedByOpponent.inv()) +
                        own.xor(own.shr(8)).xor(own.shr(16)).and(f3).and(occupiedByOpponent.inv()))
    }

    fun countByColor(color: Int): Int {
        var res = 0
        for (i in 0..23) {
            if (n[i] == color) res++
        }
        return res
    }

    fun allMills(): Boolean {
        for (i in 0..23) {
            if (n[i] == -turn && !rowOfThree(i)) return false
        }
        return true
    }

    fun occupiedRows(color: Int): Int {
        //returns a Integer representation of rows with 1 or more tokens of the given color
        val own = if (color == 1) nodes[0] else nodes[1]
        val res = own.or(own.shr(1)).or(own.shr(2)).and(f1) + own.or(own.shr(1)).or(own.shl(6)).and(f2) +
                own.or(own.shr(8)).or(own.shr(16)).and(f3)
        return res
    }

    fun countTokens(player: Int): Int {
        var res = 0
        n.forEach {
            if (it == player) res++
        }
        return res
    }

    fun gameOver(): Boolean {
        if (phs != 1 && countByColor(turn) < 3) return true
        if (possibleMoves().isEmpty()) return true
        return false
    }

    fun arrayToBits(values: IntArray): IntArray {
        // phs-turn-23-22-21-20-19-18-17-16-15-14-13-12-11-10-09-08-07-06-05-04-03-02-01-00
        //   0    0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
        val res = IntArray(2)
        for (i in 0..23) {
            res[0] = res[0].shl(1)
            res[1] = res[1].shl(1)
            if (values[23 - i] == 1) res[0] += 1
            if (values[23 - i] == -1) res[1] += 1
        }
        return res
    }

    override fun toString(): String {
        var res = ""
        repeat(24) {
            res += "${n[it]},"
        }
        val black = countTokens(-1)
        val white = countTokens(1)
        val eval = turn * heuristicEval()
        res += "$sel,$turn," + (if (gameOver()) (if (-turn == 1) 1 else 2) else 0) + ",$phs" + ",$white,$black,$eval"
        return res
    }

    fun stats(): String {
        println("node0: ${nodeAsBinary(0, 1)}")
        println("node1: ${nodeAsBinary(1, -1)}")
        println("node7: ${nodeAsBinary(7, -1)}")
//        O--------O--------O   turn:
//        |  O-----O-----O  |   phase:
//        |  |  O--O--O  |  |   available:
//        O--O--O     O--O--O   heuristic evaluation:
//        |  |  O--O--O  |  |
//        |  O-----O-----O  |
//        O--------O--------O
        val t = CharArray(24)
        n.forEachIndexed { i, it ->
            if (it == -1) t[i] = 'B'
            if (it == 0) t[i] = 'O'
            if (it == 1) t[i] = 'W'
        }
        val numOfRows = countAllRows(turn)
        return "${t[0]}--------${t[1]}--------${t[2]}   active player: $turn\n" +
                "|  ${t[8]}-----${t[9]}-----${t[10]}  |   phase: $phs\n" +
                "|  |  ${t[16]}--${t[17]}--${t[18]}  |  |   available: $avl\n" +
                "${t[7]}--${t[15]}--${t[23]}     ${t[19]}--${t[11]}--${t[3]}   heuristic evaluation:   ${turn * heuristicEval()}\n" +
                "|  |  ${t[22]}--${t[21]}--${t[20]}  |  |   rows of 3: ${numOfRows[2]}\n" +
                "|  ${t[14]}-----${t[13]}-----${t[12]}  |   rows of 2: ${numOfRows[1]}\n" +
                "${t[6]}--------${t[5]}--------${t[4]}   rows of 1: ${numOfRows[0]}\n"
    }

    fun takable(node: Int): Boolean {
        if (n[node] == -turn && (!rowOfThree(node) || allMills()))
            return true
        return false
    }

    fun adj(node: Int, dir: Int): Int {
        return if (paths[node].containsKey(dir)) n[paths[node][dir] ?: error("paths[node][dir] is null!")]
        else 0
    }

    fun node(i: Int, color: Int = 0): Int {
        if (color == 0) {
            if (nodes[0].and(1.shl(i)) > 0) return 1
            if (nodes[1].and(1.shl(i)) > 0) return -1
        }
        if (color == 1 && nodes[0].and(1.shl(i)) > 0) return 1
        if (color == -1 && nodes[1].and(1.shl(i)) > 0) return 1
        return 0
    }

    fun nodeAsBinary(i: Int, color: Int = 0): Int {
        return if (node(i, color) == 1) nodeToBinary(i) else 0
    }

    fun nodeToBinary(i: Int): Int {
        return 1.shl(i)
    }

    fun countBits(bits: Int): Int {
        var count = 0
        var tmp = bits
        while (tmp != 0) {
            count += tmp % 2
            tmp = tmp.shr(1)
        }
        return count
    }

//    fun allPossiblePositions(): List<Muehle> {
//
//        var n = IntArray(2)
//        var avl = 18            //0-18
//        var phs = 1             //-1, 0, 1
//        var turn = 1            //-1, 1
//
//        for (avl in 0..18) {
//            for (turn in intArrayOf(-1, 1)) {
//
//                    for (color in intArrayOf(-1, 0, 1)) {
//                        for (node in 0..23) {
//                        n[node] = color
//                    }
//                }
//            }
//        }
//        return allPositions
//    }

//    fun buildPos() {
//        possibleNodes.forEach { it ->
            //all Pos with avl>0
//            if (it[24] > 0)
//                for (turn in intArrayOf(-1, 1)) {
//                    for (phs in intArrayOf(-1, 1))
//                        allPos.add(Muehle(it.copyOfRange(0, 23), -1, turn, it[24], phs, null))
//                }

            //all Pos with avl=0
//            else {
//                for (turn in intArrayOf(-1, 1)) {
//                    for (phs in intArrayOf(-1, 0))
//                        allPos.add(Muehle(it.copyOfRange(0, 23), -1, turn, 0, phs, null))
//                }
//            }
//        }
//    }

//    fun buildField(n: IntArray, pos: Int, white: Int, black: Int) {
////        var turn = 1
////        var avl = 18
////        var phs = 1
////        if (pos==24) list.add(Muehle(arrayToBits(n),-1,turn,avl,phs,null))
//        if (pos == 24) {
//            possibleNodes.add(intArrayOf(*n, avl, black, white))
//            return
//        }
//
//        for (avl in 0..1) {
//            if (white + avl / 2 < 9) {
//                n[pos] = 1
//                buildField(n, pos + 1, white + 1, black)
//            }
//
//            if (black + avl / 2 < 9) {
//                n[pos] = -1
//                buildField(n, pos + 1, white, black)
//            }
//
//            n[pos] = 0
//            buildField(n, pos + 1, white, black)
//        }
//    }

    fun evaluateRandom(limit: Int) {
        println("reached evaluateRandom")
        if (limit==0) return
        evaluate(myMap,turn,0)
        val next: Muehle
        if (!gameOver()) {
            next = play(randomMove())
            next.evaluateRandom(limit-1)
        }
        else evaluate(myMap,turn,0)
    }

    fun buildDatabase() {
        val possMoves = possibleMoves()
        possMoves.forEach {
            start = System.currentTimeMillis()
            evaluateRandom(3)
        }
        saveData()
    }

    fun saveData() {
        //save HashMap to .txt
        val fileName = "src/main/resources/database.txt"
        val database = File(fileName)

        database.printWriter().use { out ->
            for (el in myMap) {
                out.println("${el.key},${el.value}")
            }
        }
        println("saved ${myMap.keys.size} entries in database")
    }

    fun noise(value: Int): Int = value //+ ((0..200).random() - 100)

}



class Move(val from: Int, val to: Int, val take: Int = -1) {
    override fun toString(): String {
        return "Move: $from -> $to"
    }
}   //from node to node, -1 is outside game
